

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dippykit.metrics &mdash; dippykit  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="dippykit  documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> dippykit
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.html">dippykit package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.adjustments.html">dippykit.adjustments module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.coding.html">dippykit.coding module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.image_io.html">dippykit.image_io module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.metrics.html">dippykit.metrics module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.sampling.html">dippykit.sampling module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.transforms.html">dippykit.transforms module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.utilities.html">dippykit.utilities module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.visualization.html">dippykit.visualization module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.windows.html">dippykit.windows module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dippykit</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>dippykit.metrics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for dippykit.metrics</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module of various metrics-based functions</span>

<span class="sd">This module contains an assortment of functions that provide insight into</span>
<span class="sd">image and signal data. They provide a means for high-level analysis.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Internal imports</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_utils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">utilities</span>

<span class="c1"># Functional imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">uniform_filter</span><span class="p">,</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="k">import</span> <span class="n">compare_ssim</span>

<span class="c1"># General imports</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Brighton Ancelin&#39;</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PSNR&#39;</span><span class="p">,</span> <span class="s1">&#39;contrast&#39;</span><span class="p">,</span> <span class="s1">&#39;MSE&#39;</span><span class="p">,</span> <span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="s1">&#39;MAD&#39;</span><span class="p">,</span> <span class="s1">&#39;MADev&#39;</span><span class="p">,</span> <span class="s1">&#39;entropy&#39;</span><span class="p">,</span>
           <span class="s1">&#39;SSIM&#39;</span><span class="p">,</span> <span class="s1">&#39;SSIM_luminance&#39;</span><span class="p">,</span> <span class="s1">&#39;SSIM_contrast&#39;</span><span class="p">,</span> <span class="s1">&#39;SSIM_structure&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="PSNR"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.PSNR">[docs]</a><span class="k">def</span> <span class="nf">PSNR</span><span class="p">(</span>
        <span class="n">im_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">im_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">max_signal_value</span><span class="p">:</span> <span class="n">_utils</span><span class="o">.</span><span class="n">NumericType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculates the **peak signal-to-noise ratio** between two images in dB</span>

<span class="sd">    Calculates the peak signal-to-noise ratio in decibels between two input</span>
<span class="sd">    images. The ratio is defined as -20 * log\ :subscript:`10`\ </span>
<span class="sd">    (max_signal_value / X) where max_signal_value is the maximum possible </span>
<span class="sd">    value in either image and X is the mean of all elements in the ndarray </span>
<span class="sd">    (im_1 - im_2)\ :superscript:`2`\ . The two images must have the same </span>
<span class="sd">    dtype.</span>
<span class="sd">    </span>
<span class="sd">    If max_signal_value is not specified and the two images have unsigned </span>
<span class="sd">    integer dtype, then max_signal_value is assumed to be the largest value </span>
<span class="sd">    possible in the dtype. If max_signal_value is not specified and the two </span>
<span class="sd">    images have float dtype and all their values are between 0.0 and 1.0 </span>
<span class="sd">    inclusive, then max_signal_value is assumed to be 1.0.</span>

<span class="sd">    :type im_1: ``numpy.ndarray``</span>
<span class="sd">    :param im_1: An image to be compared.</span>
<span class="sd">    :type im_2: ``numpy.ndarray``</span>
<span class="sd">    :param im_2: An image to be compared.</span>
<span class="sd">    :type max_signal_value: ``int`` or ``float``</span>
<span class="sd">    :param max_signal_value: (Optional) The maximum *possible* signal value in </span>
<span class="sd">        either image. (This is not necessarily the maximum value of either </span>
<span class="sd">        image).</span>
<span class="sd">    :rtype: ``float``</span>
<span class="sd">    :return: The decibel peak signal-to-noise ratio.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im = np.array([[0.5  , 0.125],</span>
<span class="sd">    ...                [0.25 , 0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; im_2 = im / 2</span>
<span class="sd">    &gt;&gt;&gt; PSNR(im, im_2)</span>
<span class="sd">    16.880806619058927</span>
<span class="sd">    &gt;&gt;&gt; im = np.array([[100,  20],</span>
<span class="sd">    ...                [ 40,   0]])</span>
<span class="sd">    &gt;&gt;&gt; im_2 = im / 2</span>
<span class="sd">    &gt;&gt;&gt; PSNR(im, im_2, 255)</span>
<span class="sd">    19.380190974762105</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">im_1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">im_2</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;The two images must have the same dtype&quot;</span>
    <span class="k">if</span> <span class="n">max_signal_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">float_cond</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span> <span class="o">==</span> <span class="n">im_1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">and</span> \
                     <span class="mf">1.0</span> <span class="o">&gt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">im_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">im_2</span><span class="p">))</span> <span class="ow">and</span> \
                     <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">im_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">im_2</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">float_cond</span> <span class="ow">or</span> <span class="s1">&#39;u&#39;</span> <span class="o">==</span> <span class="n">im_1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> \
                <span class="s2">&quot;Without a specified max_signal_value, the PSNR can only be &quot;</span> \
                <span class="s2">&quot;calculated for images with unsigned integer dtypes or &quot;</span> \
                <span class="s2">&quot;float dtypes with values normalized between 0.0 and 1.0. &quot;</span> \
                <span class="s2">&quot;Please either specify a max_signal_value or convert the &quot;</span> \
                <span class="s2">&quot;images to an unsigned integer dtype.&quot;</span>
        <span class="k">if</span> <span class="n">float_cond</span><span class="p">:</span>
            <span class="n">max_signal_value</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_signal_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">im_1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">error_diff</span> <span class="o">=</span> <span class="n">im_1</span> <span class="o">-</span> <span class="n">im_2</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">error_diff</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">max_signal_value</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">error_diff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="contrast"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.contrast">[docs]</a><span class="k">def</span> <span class="nf">contrast</span><span class="p">(</span>
        <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculates the **contrast value** of an image</span>

<span class="sd">    Calculates the contrast value of an image. The contrast value of the</span>
<span class="sd">    image is defined as the difference between the maximum pixel value and</span>
<span class="sd">    the minimum pixel value divided by the sum of the same values.</span>
<span class="sd">    Therefore, the return value of this function is a float between 0.0 and</span>
<span class="sd">    1.0.</span>

<span class="sd">    :type im: ``numpy.ndarray``</span>
<span class="sd">    :param im: An image to be examined.</span>
<span class="sd">    :rtype: ``float``</span>
<span class="sd">    :return: The contrast value of the image (float between 0.0 and 1.0).</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im_1 = np.array([[0.5  , 0.125],</span>
<span class="sd">    ...                  [0.25 , 0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; contrast(im_1)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; im_2 = np.array([[125, 125],</span>
<span class="sd">    ...                  [125, 125]])</span>
<span class="sd">    &gt;&gt;&gt; contrast(im_2)</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">min_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">max_pixel</span> <span class="o">-</span> <span class="n">min_pixel</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_pixel</span> <span class="o">+</span> <span class="n">min_pixel</span><span class="p">)</span></div>


<div class="viewcode-block" id="MSE"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.MSE">[docs]</a><span class="k">def</span> <span class="nf">MSE</span><span class="p">(</span>
        <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">im_ref</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculates the **mean squared error** of an image or images</span>

<span class="sd">    * **For one image argument:**</span>
<span class="sd">        Calculates the mean squared error of an error image. The mean squared</span>
<span class="sd">        error is defined as the mean of all squared elements in the error</span>
<span class="sd">        image.</span>

<span class="sd">    * **For two image arguments:**</span>
<span class="sd">        Calculates the mean squared error between two images. The mean squared</span>
<span class="sd">        error is defined as the mean of all squared elements in the ndarray</span>
<span class="sd">        (im - im_ref).</span>

<span class="sd">    :type im: ``numpy.ndarray``</span>
<span class="sd">    :param im: An image to be examined.</span>
<span class="sd">    :type im_ref: ``numpy.ndarray``</span>
<span class="sd">    :param im_ref: (Optional) A reference image for im to be compared against.</span>
<span class="sd">    :rtype: ``float``</span>
<span class="sd">    :return: The mean squared error of the image(s).</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im_1 = np.array([[0.5  , 0.125],</span>
<span class="sd">    ...                  [0.25 , 0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; MSE(im_1)</span>
<span class="sd">    0.08203125</span>
<span class="sd">    &gt;&gt;&gt; im_2 = np.array([[0.   , 0.125],</span>
<span class="sd">    ...                  [0.25 , 0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; MSE(im_1, im_2)</span>
<span class="sd">    0.0625</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">im_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">im</span> <span class="o">-</span> <span class="n">im_ref</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="energy"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.energy">[docs]</a><span class="k">def</span> <span class="nf">energy</span><span class="p">(</span>
        <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculates the **energy** of an image</span>

<span class="sd">    Calculates the energy of an image. The energy is defined as the sum of</span>
<span class="sd">    all squared elements in the image.</span>

<span class="sd">    :type im: ``numpy.ndarray``</span>
<span class="sd">    :param im: An image to be examined.</span>
<span class="sd">    :rtype: ``float``</span>
<span class="sd">    :return: The energy of the image.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im_1 = np.array([[0.5  , 0.125],</span>
<span class="sd">    ...                  [0.25 , 0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; energy(im_1)</span>
<span class="sd">    0.328125</span>
<span class="sd">    &gt;&gt;&gt; im_2 = np.array([[125, 125],</span>
<span class="sd">    ...                  [125, 125]])</span>
<span class="sd">    &gt;&gt;&gt; energy(im_2)</span>
<span class="sd">    62500</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="MAD"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.MAD">[docs]</a><span class="k">def</span> <span class="nf">MAD</span><span class="p">(</span>
        <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">im_ref</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculates the **mean absolute difference** of an image or images</span>

<span class="sd">    * **For one image argument:**</span>
<span class="sd">        Calculates the mean absolute difference of an error image. The mean</span>
<span class="sd">        absolute difference is defined as the mean of the absolute value of</span>
<span class="sd">        all elements in the error image.</span>

<span class="sd">    * **For two image arguments:**</span>
<span class="sd">        Calculates the mean absolute difference between two images. The mean</span>
<span class="sd">        absolute difference is defined as the mean of the absolute value of</span>
<span class="sd">        all elements in the ndarray (im - im_ref).</span>

<span class="sd">    :type im: ``numpy.ndarray``</span>
<span class="sd">    :param im: An image to be examined.</span>
<span class="sd">    :type im_ref: ``numpy.ndarray``</span>
<span class="sd">    :param im_ref: (Optional) A reference image for im to be compared against.</span>
<span class="sd">    :rtype: ``float``</span>
<span class="sd">    :return: The mean absolute difference of the image(s).</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im_1 = np.array([[0.5  , 0.125],</span>
<span class="sd">    ...                  [0.25 , 0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; MAD(im_1)</span>
<span class="sd">    0.21875</span>
<span class="sd">    &gt;&gt;&gt; im_2 = np.array([[0.   , 0.125],</span>
<span class="sd">    ...                  [0.25 , 0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; MAD(im_1, im_2)</span>
<span class="sd">    0.125</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">im_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span> \
        <span class="s2">&quot;MAD calculations require that images be the same shape&quot;</span>
    <span class="k">if</span> <span class="n">im_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;u&#39;</span> <span class="o">==</span> <span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;u&#39;</span> <span class="o">==</span> <span class="n">im_ref</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">:</span>
            <span class="n">im_ref</span> <span class="o">=</span> <span class="n">im_ref</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span> <span class="o">-</span> <span class="n">im_ref</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span><span class="p">))</span></div>


<div class="viewcode-block" id="MADev"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.MADev">[docs]</a><span class="k">def</span> <span class="nf">MADev</span><span class="p">(</span>
        <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculates the **mean absolute deviation** of an image</span>

<span class="sd">    Calculates the mean absolute deviation of an image. The mean absolute</span>
<span class="sd">    deviation is defined as the mean of the absolute value of all</span>
<span class="sd">    differences between elements in the image and the mean value of all</span>
<span class="sd">    elements in the image.</span>

<span class="sd">    :type im: ``numpy.ndarray``</span>
<span class="sd">    :param im: An image to be examined.</span>
<span class="sd">    :rtype: ``float``</span>
<span class="sd">    :return: The mean absolute deviation of the image.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im_1 = np.array([[15, 15],</span>
<span class="sd">    ...                  [15, 15]])</span>
<span class="sd">    &gt;&gt;&gt; MADev(im_1)</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; im_2 = np.array([[15, 20],</span>
<span class="sd">    ...                  [10, 15]])</span>
<span class="sd">    &gt;&gt;&gt; MADev(im_2)</span>
<span class="sd">    2.5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">im</span><span class="p">)))</span></div>


<div class="viewcode-block" id="entropy"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.entropy">[docs]</a><span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span>
        <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculates the **entropy** of an image</span>

<span class="sd">    Calculates the entropy of an image. The entropy is equivalent to the</span>
<span class="sd">    expected value of the number of bits used to encode a single pixel in</span>
<span class="sd">    the optimal encoding case. It is a lower bound on the amount of</span>
<span class="sd">    information required to represent the image (per pixel). The entropy is</span>
<span class="sd">    defined by the sum of all pixel value probabilities times the</span>
<span class="sd">    logarithm-base-2 of the inverse pixel probability.</span>

<span class="sd">    This function requires that the input image have either an integer or</span>
<span class="sd">    unsigned integer dtype.</span>

<span class="sd">    :type im: ``numpy.ndarray``</span>
<span class="sd">    :param im: An image to be examined.</span>
<span class="sd">    :rtype: ``float``</span>
<span class="sd">    :return: The entropy of the image.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im_1 = np.array([[15, 15],</span>
<span class="sd">    ...                  [15, 15]])</span>
<span class="sd">    &gt;&gt;&gt; entropy(im_1)</span>
<span class="sd">    -0.0</span>
<span class="sd">    &gt;&gt;&gt; im_2 = np.array([[15, 20],</span>
<span class="sd">    ...                  [10, 15]])</span>
<span class="sd">    &gt;&gt;&gt; entropy(im_2)</span>
<span class="sd">    1.5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="s1">&#39;i&#39;</span> <span class="o">==</span> <span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">or</span> <span class="s1">&#39;u&#39;</span> <span class="o">==</span> <span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> \
            <span class="s2">&quot;Image dtype must be integer for entropy to be calculated&quot;</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">bin_probs</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">bins</span><span class="p">]</span>
    <span class="n">bin_probs</span> <span class="o">=</span> <span class="n">bin_probs</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_probs</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_probs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">bin_probs</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">_SSIM_preprocess</span><span class="p">(</span>
        <span class="n">im_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">im_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">K1</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">K2</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
        <span class="n">use_gaussian_window</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_range</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">auto_downsample</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_sample_covariance</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">like_matlab</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="n">window_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;win_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">window_size</span>
    <span class="k">if</span> <span class="n">data_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;data_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_range</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;full&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;K1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">K1</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;K2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">K2</span>
    <span class="k">if</span> <span class="n">use_gaussian_window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;gaussian_weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">use_gaussian_window</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">like_matlab</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;gaussian_weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">use_sample_covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;use_sample_covariance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">use_sample_covariance</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">like_matlab</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;use_sample_covariance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">like_matlab</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;win_size&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;win_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11</span>
        <span class="k">if</span> <span class="s1">&#39;data_range&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># Be careful; the Matlab-like implementation always uses</span>
            <span class="c1"># data_range=255 regardless of dtype. This may not be what you</span>
            <span class="c1"># want!</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;data_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
        <span class="k">if</span> <span class="s1">&#39;sigma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
        <span class="k">if</span> <span class="s1">&#39;full&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;full&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s1">&#39;K1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;K1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="k">if</span> <span class="s1">&#39;K2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;K2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.03</span>
        <span class="k">if</span> <span class="s1">&#39;gaussian_weights&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;gaussian_weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s1">&#39;use_sample_covariance&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;use_sample_covariance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">auto_downsample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">auto_downsample</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">auto_downsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">auto_downsample</span><span class="p">:</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">im_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">im_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">256</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-9</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">scale_factor</span><span class="p">:</span>
            <span class="n">low_pass_filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">scale_factor</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">))</span>
            <span class="n">low_pass_filter</span> <span class="o">/=</span> <span class="n">scale_factor</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">im_1</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">low_pass_filter</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span>
                    <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">like_matlab</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">im_1</span> <span class="o">=</span> <span class="n">im_1</span><span class="p">[::</span><span class="n">scale_factor</span><span class="p">,</span> <span class="p">::</span><span class="n">scale_factor</span><span class="p">]</span>
            <span class="n">im_2</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">im_2</span><span class="p">,</span> <span class="n">low_pass_filter</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span>
                    <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">like_matlab</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">im_2</span> <span class="o">=</span> <span class="n">im_2</span><span class="p">[::</span><span class="n">scale_factor</span><span class="p">,</span> <span class="p">::</span><span class="n">scale_factor</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_SSIM_like_matlab_crop</span><span class="p">(</span>
        <span class="n">ssim_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;win_size&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">ssim_map</span><span class="p">[</span><span class="n">pad</span><span class="p">:(</span><span class="n">ssim_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">),</span>
                    <span class="n">pad</span><span class="p">:(</span><span class="n">ssim_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">)]</span>


<div class="viewcode-block" id="SSIM"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.SSIM">[docs]</a><span class="k">def</span> <span class="nf">SSIM</span><span class="p">(</span>
        <span class="n">im_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">im_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">K1</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">K2</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
        <span class="n">use_gaussian_window</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_range</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">auto_downsample</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_sample_covariance</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">like_matlab</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns the mean SSIM index and SSIM image for a comparison of two </span>
<span class="sd">    images</span>
<span class="sd">    </span>
<span class="sd">    Given two images, this function will return the mean SSIM index and the </span>
<span class="sd">    full SSIM image.</span>

<span class="sd">    This function is essentially a wrapper for</span>
<span class="sd">    `skimage.measure.compare_ssim`_, so more detailed documentation may be</span>
<span class="sd">    found there.</span>
<span class="sd">    </span>
<span class="sd">    :type im_1: ``numpy.ndarray``</span>
<span class="sd">    :param im_1: The first image in the comparison</span>
<span class="sd">    :type im_2: ``numpy.ndarray``</span>
<span class="sd">    :param im_2: The second image in the comparison</span>
<span class="sd">    :type K1: ``float``</span>
<span class="sd">    :param K1: (default=0.01) The K1 parameter used in the SSIM calculation</span>
<span class="sd">    :type K2: ``float``</span>
<span class="sd">    :param K2: (default=0.03) The K2 parameter used in the SSIM calculation</span>
<span class="sd">    :type use_gaussian_window: ``bool``</span>
<span class="sd">    :param use_gaussian_window: (default=False) If set to True, </span>
<span class="sd">        this function will use a gaussian window for the SSIM calculation </span>
<span class="sd">    :type window_size: ``int``</span>
<span class="sd">    :param window_size: (Optional) The size of the window to be used in the </span>
<span class="sd">        SSIM calculation. If **use_gaussian_window** is set to True, </span>
<span class="sd">        then this argument is ignored. </span>
<span class="sd">    :type data_range: ``float``</span>
<span class="sd">    :param data_range: (Optional) The range of values that the image can span. </span>
<span class="sd">        If this parameter is not set, then the range will be determined </span>
<span class="sd">        from the minimum and maximum values of the images. For uint8 </span>
<span class="sd">        images, this value should be 255.</span>
<span class="sd">    :type sigma: ``float``</span>
<span class="sd">    :param sigma: (Optional) If **use_gaussian_window** is set to True, </span>
<span class="sd">        this parameter determines the sigma used for the gaussian window.</span>
<span class="sd">    :type auto_downsample: ``bool``</span>
<span class="sd">    :param auto_downsample: (default=True) If set to True, this function will</span>
<span class="sd">        automatically downsample the inputs. The downsampling consists of</span>
<span class="sd">        finding the smallest of the images&#39; first two dimensions (number of</span>
<span class="sd">        rows and number of columns), dividing this value by 256, rounding</span>
<span class="sd">        the output, and setting this final value as the scaling factor (sf). A</span>
<span class="sd">        square (sf x sf) lowpass averaging filter is then applied to both</span>
<span class="sd">        images with mode &#39;same&#39;. Finally, the two images are downsampled by</span>
<span class="sd">        sf in each dimension.</span>
<span class="sd">    :type use_sample_covariance: ``bool``</span>
<span class="sd">    :param use_sample_covariance: (default=False) If set to True,</span>
<span class="sd">        this function will use sample covariances in its calculations.</span>
<span class="sd">        Otherwise, covariances of 1 will be used.</span>
<span class="sd">    :type like_matlab: ``bool``</span>
<span class="sd">    :param like_matlab: If set to True, this function will act like the</span>
<span class="sd">        Matlab function ssim_index. This is merely a specific configuration</span>
<span class="sd">        of the above parameters.</span>
<span class="sd">    :param kwargs: For a full list of keyword arguments, see</span>
<span class="sd">        `skimage.measure.compare_ssim`_.</span>
<span class="sd">    :rtype: ``(float, numpy.ndarray)``</span>
<span class="sd">    :return: A tuple of two elements. The first element is the mean SSIM </span>
<span class="sd">        index. The second element is the full SSIM image.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function wraps around functions from other packages. Reading</span>
<span class="sd">        these functions&#39; documentations may be useful. See the **See also**</span>
<span class="sd">        section for more information.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        `skimage.measure.compare_ssim`_</span>
<span class="sd">            Documentation of the compare_ssim function from Scikit Image</span>
<span class="sd">        `SSIM Wikipedia Page`_</span>
<span class="sd">            Wikipedia page describing the formulae for SSIM calculations</span>

<span class="sd">    .. _skimage.measure.compare_ssim: http://scikit-image.org/docs/dev/api/</span>
<span class="sd">        skimage.measure.html#skimage.measure.compare_ssim</span>

<span class="sd">    .. _SSIM Wikipedia Page: https://en.wikipedia.org/wiki/</span>
<span class="sd">        Structural_similarity#Formula_components</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_SSIM_preprocess</span><span class="p">(</span><span class="n">im_1</span><span class="o">=</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="o">=</span><span class="n">im_2</span><span class="p">,</span> <span class="n">K1</span><span class="o">=</span><span class="n">K1</span><span class="p">,</span>
            <span class="n">K2</span><span class="o">=</span><span class="n">K2</span><span class="p">,</span> <span class="n">use_gaussian_window</span><span class="o">=</span><span class="n">use_gaussian_window</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data_range</span><span class="o">=</span><span class="n">data_range</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">auto_downsample</span><span class="o">=</span><span class="n">auto_downsample</span><span class="p">,</span>
            <span class="n">use_sample_covariance</span><span class="o">=</span><span class="n">use_sample_covariance</span><span class="p">,</span>
            <span class="n">like_matlab</span><span class="o">=</span><span class="n">like_matlab</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">like_matlab</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">compare_ssim</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mssim</span><span class="p">,</span> <span class="n">ssim_map</span> <span class="o">=</span> <span class="n">compare_ssim</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">_SSIM_like_matlab_crop</span><span class="p">(</span><span class="n">ssim_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_compare_ssim_with_callback</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span>
        <span class="n">Y</span><span class="p">,</span>
        <span class="n">callback_func</span><span class="p">,</span>
        <span class="n">win_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">data_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">multichannel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">gaussian_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">full</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The following code was copied and modified from</span>
<span class="sd">    skimage.measure.compare_ssim. The modifications were adding a callback</span>
<span class="sd">    feature to the algorithm. This allows for targeted SSIM calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">Y</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input images must have the same dtype.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input images must have the same dimensions.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">multichannel</span><span class="p">:</span>
        <span class="c1"># loop over channels</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">win_size</span><span class="o">=</span><span class="n">win_size</span><span class="p">,</span>
                    <span class="n">gradient</span><span class="o">=</span><span class="n">gradient</span><span class="p">,</span>
                    <span class="n">data_range</span><span class="o">=</span><span class="n">data_range</span><span class="p">,</span>
                    <span class="n">multichannel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">gaussian_weights</span><span class="o">=</span><span class="n">gaussian_weights</span><span class="p">,</span>
                    <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">nch</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mssim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gradient</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nch</span><span class="p">):</span>
            <span class="n">ch_result</span> <span class="o">=</span> <span class="n">_compare_ssim_with_callback</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">],</span>
                    <span class="n">callback_func</span><span class="o">=</span><span class="n">callback_func</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gradient</span> <span class="ow">and</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">mssim</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_result</span>
            <span class="k">elif</span> <span class="n">gradient</span><span class="p">:</span>
                <span class="n">mssim</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_result</span>
            <span class="k">elif</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">mssim</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mssim</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_result</span>
        <span class="n">mssim</span> <span class="o">=</span> <span class="n">mssim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">gradient</span> <span class="ow">and</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">S</span>
        <span class="k">elif</span> <span class="n">gradient</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">G</span>
        <span class="k">elif</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mssim</span>

    <span class="n">K1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;K1&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="n">K2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;K2&#39;</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">K1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;K1 must be positive&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">K2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;K2 must be positive&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sigma must be positive&quot;</span><span class="p">)</span>
    <span class="n">use_sample_covariance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;use_sample_covariance&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">win_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gaussian_weights</span><span class="p">:</span>
            <span class="n">win_size</span> <span class="o">=</span> <span class="mi">11</span>  <span class="c1"># 11 to match Wang et. al. 2004</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">win_size</span> <span class="o">=</span> <span class="mi">7</span>   <span class="c1"># backwards compatibility</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">win_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;win_size exceeds image extent.  If the input is a multichannel &quot;</span>
            <span class="s2">&quot;(color) image, set multichannel=True.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">win_size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Window size must be odd.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;iu&#39;</span><span class="p">:</span>
            <span class="n">dinfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">dinfo</span><span class="o">.</span><span class="n">min</span>
            <span class="n">dmax</span> <span class="o">=</span> <span class="n">dinfo</span><span class="o">.</span><span class="n">max</span>
        <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dtype not recognized and data_range is None is &#39;</span>
                             <span class="s1">&#39;not allowed&#39;</span><span class="p">)</span>
        <span class="n">data_range</span> <span class="o">=</span> <span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="n">gaussian_weights</span><span class="p">:</span>
        <span class="c1"># sigma = 1.5 to approximately match filter in Wang et. al. 2004</span>
        <span class="c1"># this ends up giving a 13-tap rather than 11-tap Gaussian</span>
        <span class="n">filter_func</span> <span class="o">=</span> <span class="n">gaussian_filter</span>
        <span class="n">filter_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="n">sigma</span><span class="p">}</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">filter_func</span> <span class="o">=</span> <span class="n">uniform_filter</span>
        <span class="n">filter_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">win_size</span><span class="p">}</span>

    <span class="c1"># ndimage filters need floating point data</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">NP</span> <span class="o">=</span> <span class="n">win_size</span> <span class="o">**</span> <span class="n">ndim</span>

    <span class="c1"># filter has already normalized by NP</span>
    <span class="k">if</span> <span class="n">use_sample_covariance</span><span class="p">:</span>
        <span class="n">cov_norm</span> <span class="o">=</span> <span class="n">NP</span> <span class="o">/</span> <span class="p">(</span><span class="n">NP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># sample covariance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cov_norm</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># population covariance to match Wang et. al. 2004</span>

    <span class="c1"># compute (weighted) means</span>
    <span class="n">ux</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_args</span><span class="p">)</span>
    <span class="n">uy</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_args</span><span class="p">)</span>

    <span class="c1"># compute (weighted) variances and covariances</span>
    <span class="n">uxx</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_args</span><span class="p">)</span>
    <span class="n">uyy</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">Y</span> <span class="o">*</span> <span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_args</span><span class="p">)</span>
    <span class="n">uxy</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_args</span><span class="p">)</span>
    <span class="n">vx</span> <span class="o">=</span> <span class="n">cov_norm</span> <span class="o">*</span> <span class="p">(</span><span class="n">uxx</span> <span class="o">-</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">ux</span><span class="p">)</span>
    <span class="n">vy</span> <span class="o">=</span> <span class="n">cov_norm</span> <span class="o">*</span> <span class="p">(</span><span class="n">uyy</span> <span class="o">-</span> <span class="n">uy</span> <span class="o">*</span> <span class="n">uy</span><span class="p">)</span>
    <span class="n">vxy</span> <span class="o">=</span> <span class="n">cov_norm</span> <span class="o">*</span> <span class="p">(</span><span class="n">uxy</span> <span class="o">-</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">uy</span><span class="p">)</span>

    <span class="c1"># Have to include the non-negative assertion (rounding errors) because</span>
    <span class="c1"># some metrics may want to use standard deviation (sqrt of variance),</span>
    <span class="c1"># which would otherwise be an issue</span>
    <span class="n">vx</span><span class="p">[</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vy</span><span class="p">[</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vxy</span><span class="p">[</span><span class="n">vxy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">data_range</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="p">(</span><span class="n">K1</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="p">(</span><span class="n">K2</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">B2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">uy</span> <span class="o">+</span> <span class="n">C1</span><span class="p">,</span>
                       <span class="mi">2</span> <span class="o">*</span> <span class="n">vxy</span> <span class="o">+</span> <span class="n">C2</span><span class="p">,</span>
                       <span class="n">ux</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">uy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">C1</span><span class="p">,</span>
                       <span class="n">vx</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">+</span> <span class="n">C2</span><span class="p">))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">B1</span> <span class="o">*</span> <span class="n">B2</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">callback_func</span><span class="p">(</span><span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uxx</span><span class="p">,</span> <span class="n">uyy</span><span class="p">,</span> <span class="n">uxy</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vxy</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">)</span>

    <span class="c1"># to avoid edge effects will ignore filter radius strip around edges</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="p">(</span><span class="n">win_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># compute (weighted) mean of ssim</span>
    <span class="n">mssim</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">pad</span><span class="p">:(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pad</span><span class="p">),</span> <span class="n">pad</span><span class="p">:(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pad</span><span class="p">)]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">gradient</span><span class="p">:</span>
        <span class="c1"># The following is Eqs. 7-8 of Avanaki 2009.</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">A1</span> <span class="o">/</span> <span class="n">D</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_args</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span>
        <span class="n">grad</span> <span class="o">+=</span> <span class="n">filter_func</span><span class="p">(</span><span class="o">-</span><span class="n">S</span> <span class="o">/</span> <span class="n">B2</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_args</span><span class="p">)</span> <span class="o">*</span> <span class="n">Y</span>
        <span class="n">grad</span> <span class="o">+=</span> <span class="n">filter_func</span><span class="p">((</span><span class="n">ux</span> <span class="o">*</span> <span class="p">(</span><span class="n">A2</span> <span class="o">-</span> <span class="n">A1</span><span class="p">)</span> <span class="o">-</span> <span class="n">uy</span> <span class="o">*</span> <span class="p">(</span><span class="n">B2</span> <span class="o">-</span> <span class="n">B1</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span><span class="p">)</span> <span class="o">/</span> <span class="n">D</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">filter_args</span><span class="p">)</span>
        <span class="n">grad</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">grad</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mssim</span>


<div class="viewcode-block" id="SSIM_luminance"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.SSIM_luminance">[docs]</a><span class="k">def</span> <span class="nf">SSIM_luminance</span><span class="p">(</span>
        <span class="n">im_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">im_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">K1</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">K2</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
        <span class="n">use_gaussian_window</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_range</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">auto_downsample</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_sample_covariance</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">like_matlab</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns the mean luminance component of the SSIM index and luminance</span>
<span class="sd">    component of the SSIM image for a comparison of two images</span>

<span class="sd">    Given two images, this function will return the mean luminance component</span>
<span class="sd">    of the SSIM index and luminance component of the full SSIM image.</span>

<span class="sd">    This function is heavily based on `skimage.measure.compare_ssim`_,</span>
<span class="sd">    so more detailed documentation may be found there.</span>

<span class="sd">    :type im_1: ``numpy.ndarray``</span>
<span class="sd">    :param im_1: The first image in the comparison</span>
<span class="sd">    :type im_2: ``numpy.ndarray``</span>
<span class="sd">    :param im_2: The second image in the comparison</span>
<span class="sd">    :type K1: ``float``</span>
<span class="sd">    :param K1: (default=0.01) The K1 parameter used in the SSIM calculation</span>
<span class="sd">    :type K2: ``float``</span>
<span class="sd">    :param K2: (default=0.03) The K2 parameter used in the SSIM calculation</span>
<span class="sd">    :type use_gaussian_window: ``bool``</span>
<span class="sd">    :param use_gaussian_window: (default=False) If set to True,</span>
<span class="sd">        this function will use a gaussian window for the SSIM calculation</span>
<span class="sd">    :type window_size: ``int``</span>
<span class="sd">    :param window_size: (Optional) The size of the window to be used in the</span>
<span class="sd">        SSIM calculation. If **use_gaussian_window** is set to True,</span>
<span class="sd">        then this argument is ignored.</span>
<span class="sd">    :type data_range: ``float``</span>
<span class="sd">    :param data_range: (Optional) The range of values that the image can span.</span>
<span class="sd">        If this parameter is not set, then the range will be determined</span>
<span class="sd">        from the minimum and maximum values of the images. For uint8</span>
<span class="sd">        images, this value should be 255.</span>
<span class="sd">    :type sigma: ``float``</span>
<span class="sd">    :param sigma: (Optional) If **use_gaussian_window** is set to True,</span>
<span class="sd">        this parameter determines the sigma used for the gaussian window.</span>
<span class="sd">    :type auto_downsample: ``bool``</span>
<span class="sd">    :param auto_downsample: (default=True) If set to True, this function will</span>
<span class="sd">        automatically downsample the inputs. The downsampling consists of</span>
<span class="sd">        finding the smallest of the images&#39; first two dimensions (number of</span>
<span class="sd">        rows and number of columns), dividing this value by 256, rounding</span>
<span class="sd">        the output, and setting this final value as the scaling factor (sf). A</span>
<span class="sd">        square (sf x sf) lowpass averaging filter is then applied to both</span>
<span class="sd">        images with mode &#39;same&#39;. Finally, the two images are downsampled by</span>
<span class="sd">        sf in each dimension.</span>
<span class="sd">    :type use_sample_covariance: ``bool``</span>
<span class="sd">    :param use_sample_covariance: (default=False) If set to True,</span>
<span class="sd">        this function will use sample covariances in its calculations.</span>
<span class="sd">        Otherwise, covariances of 1 will be used.</span>
<span class="sd">    :type like_matlab: ``bool``</span>
<span class="sd">    :param like_matlab: If set to True, this function will act like the</span>
<span class="sd">        Matlab function ssim_index. This is merely a specific configuration</span>
<span class="sd">        of the above parameters.</span>
<span class="sd">    :param kwargs: For a full list of keyword arguments, see</span>
<span class="sd">        `skimage.measure.compare_ssim`_.</span>
<span class="sd">    :rtype: ``(float, numpy.ndarray)``</span>
<span class="sd">    :return: A tuple of two elements. The first element is the mean SSIM</span>
<span class="sd">        index. The second element is the full SSIM image.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        `skimage.measure.compare_ssim`_</span>
<span class="sd">            Documentation of the compare_ssim function from Scikit Image</span>
<span class="sd">        `SSIM Wikipedia Page`_</span>
<span class="sd">            Wikipedia page describing the formulae for SSIM calculations</span>

<span class="sd">    .. _skimage.measure.compare_ssim: http://scikit-image.org/docs/dev/api/</span>
<span class="sd">        skimage.measure.html#skimage.measure.compare_ssim</span>

<span class="sd">    .. _SSIM Wikipedia Page: https://en.wikipedia.org/wiki/</span>
<span class="sd">        Structural_similarity#Formula_components</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_SSIM_preprocess</span><span class="p">(</span><span class="n">im_1</span><span class="o">=</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="o">=</span><span class="n">im_2</span><span class="p">,</span> <span class="n">K1</span><span class="o">=</span><span class="n">K1</span><span class="p">,</span>
            <span class="n">K2</span><span class="o">=</span><span class="n">K2</span><span class="p">,</span> <span class="n">use_gaussian_window</span><span class="o">=</span><span class="n">use_gaussian_window</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data_range</span><span class="o">=</span><span class="n">data_range</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">auto_downsample</span><span class="o">=</span><span class="n">auto_downsample</span><span class="p">,</span>
            <span class="n">use_sample_covariance</span><span class="o">=</span><span class="n">use_sample_covariance</span><span class="p">,</span>
            <span class="n">like_matlab</span><span class="o">=</span><span class="n">like_matlab</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">callback_func</span><span class="p">(</span><span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uxx</span><span class="p">,</span> <span class="n">uyy</span><span class="p">,</span> <span class="n">uxy</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vxy</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">uy</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">ux</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">uy</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">like_matlab</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compare_ssim_with_callback</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span>
                <span class="n">callback_func</span><span class="o">=</span><span class="n">callback_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mssim</span><span class="p">,</span> <span class="n">ssim_map</span> <span class="o">=</span> <span class="n">_compare_ssim_with_callback</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span>
                <span class="n">callback_func</span><span class="o">=</span><span class="n">callback_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">_SSIM_like_matlab_crop</span><span class="p">(</span><span class="n">ssim_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="SSIM_contrast"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.SSIM_contrast">[docs]</a><span class="k">def</span> <span class="nf">SSIM_contrast</span><span class="p">(</span>
        <span class="n">im_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">im_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">K1</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">K2</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
        <span class="n">use_gaussian_window</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_range</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">auto_downsample</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_sample_covariance</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">like_matlab</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns the mean contrast component of the SSIM index and contrast</span>
<span class="sd">    component of the SSIM image for a comparison of two images</span>

<span class="sd">    Given two images, this function will return the mean contrast component</span>
<span class="sd">    of the SSIM index and contrast component of the full SSIM image.</span>

<span class="sd">    This function is heavily based on `skimage.measure.compare_ssim`_,</span>
<span class="sd">    so more detailed documentation may be found there.</span>

<span class="sd">    :type im_1: ``numpy.ndarray``</span>
<span class="sd">    :param im_1: The first image in the comparison</span>
<span class="sd">    :type im_2: ``numpy.ndarray``</span>
<span class="sd">    :param im_2: The second image in the comparison</span>
<span class="sd">    :type K1: ``float``</span>
<span class="sd">    :param K1: (default=0.01) The K1 parameter used in the SSIM calculation</span>
<span class="sd">    :type K2: ``float``</span>
<span class="sd">    :param K2: (default=0.03) The K2 parameter used in the SSIM calculation</span>
<span class="sd">    :type use_gaussian_window: ``bool``</span>
<span class="sd">    :param use_gaussian_window: (default=False) If set to True,</span>
<span class="sd">        this function will use a gaussian window for the SSIM calculation</span>
<span class="sd">    :type window_size: ``int``</span>
<span class="sd">    :param window_size: (Optional) The size of the window to be used in the</span>
<span class="sd">        SSIM calculation. If **use_gaussian_window** is set to True,</span>
<span class="sd">        then this argument is ignored.</span>
<span class="sd">    :type data_range: ``float``</span>
<span class="sd">    :param data_range: (Optional) The range of values that the image can span.</span>
<span class="sd">        If this parameter is not set, then the range will be determined</span>
<span class="sd">        from the minimum and maximum values of the images. For uint8</span>
<span class="sd">        images, this value should be 255.</span>
<span class="sd">    :type sigma: ``float``</span>
<span class="sd">    :param sigma: (Optional) If **use_gaussian_window** is set to True,</span>
<span class="sd">        this parameter determines the sigma used for the gaussian window.</span>
<span class="sd">    :type auto_downsample: ``bool``</span>
<span class="sd">    :param auto_downsample: (default=True) If set to True, this function will</span>
<span class="sd">        automatically downsample the inputs. The downsampling consists of</span>
<span class="sd">        finding the smallest of the images&#39; first two dimensions (number of</span>
<span class="sd">        rows and number of columns), dividing this value by 256, rounding</span>
<span class="sd">        the output, and setting this final value as the scaling factor (sf). A</span>
<span class="sd">        square (sf x sf) lowpass averaging filter is then applied to both</span>
<span class="sd">        images with mode &#39;same&#39;. Finally, the two images are downsampled by</span>
<span class="sd">        sf in each dimension.</span>
<span class="sd">    :type use_sample_covariance: ``bool``</span>
<span class="sd">    :param use_sample_covariance: (default=False) If set to True,</span>
<span class="sd">        this function will use sample covariances in its calculations.</span>
<span class="sd">        Otherwise, covariances of 1 will be used.</span>
<span class="sd">    :type like_matlab: ``bool``</span>
<span class="sd">    :param like_matlab: If set to True, this function will act like the</span>
<span class="sd">        Matlab function ssim_index. This is merely a specific configuration</span>
<span class="sd">        of the above parameters.</span>
<span class="sd">    :param kwargs: For a full list of keyword arguments, see</span>
<span class="sd">        `skimage.measure.compare_ssim`_.</span>
<span class="sd">    :rtype: ``(float, numpy.ndarray)``</span>
<span class="sd">    :return: A tuple of two elements. The first element is the mean SSIM</span>
<span class="sd">        index. The second element is the full SSIM image.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        `skimage.measure.compare_ssim`_</span>
<span class="sd">            Documentation of the compare_ssim function from Scikit Image</span>
<span class="sd">        `SSIM Wikipedia Page`_</span>
<span class="sd">            Wikipedia page describing the formulae for SSIM calculations</span>

<span class="sd">    .. _skimage.measure.compare_ssim: http://scikit-image.org/docs/dev/api/</span>
<span class="sd">        skimage.measure.html#skimage.measure.compare_ssim</span>

<span class="sd">    .. _SSIM Wikipedia Page: https://en.wikipedia.org/wiki/</span>
<span class="sd">        Structural_similarity#Formula_components</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_SSIM_preprocess</span><span class="p">(</span><span class="n">im_1</span><span class="o">=</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="o">=</span><span class="n">im_2</span><span class="p">,</span> <span class="n">K1</span><span class="o">=</span><span class="n">K1</span><span class="p">,</span>
            <span class="n">K2</span><span class="o">=</span><span class="n">K2</span><span class="p">,</span> <span class="n">use_gaussian_window</span><span class="o">=</span><span class="n">use_gaussian_window</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data_range</span><span class="o">=</span><span class="n">data_range</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">auto_downsample</span><span class="o">=</span><span class="n">auto_downsample</span><span class="p">,</span>
            <span class="n">use_sample_covariance</span><span class="o">=</span><span class="n">use_sample_covariance</span><span class="p">,</span>
            <span class="n">like_matlab</span><span class="o">=</span><span class="n">like_matlab</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">callback_func</span><span class="p">(</span><span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uxx</span><span class="p">,</span> <span class="n">uyy</span><span class="p">,</span> <span class="n">uxy</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vxy</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">vx</span> <span class="o">*</span> <span class="n">vy</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">+</span> <span class="n">C2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">vx</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">+</span> <span class="n">C2</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">like_matlab</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compare_ssim_with_callback</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span>
                <span class="n">callback_func</span><span class="o">=</span><span class="n">callback_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mssim</span><span class="p">,</span> <span class="n">ssim_map</span> <span class="o">=</span> <span class="n">_compare_ssim_with_callback</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span>
                <span class="n">callback_func</span><span class="o">=</span><span class="n">callback_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">_SSIM_like_matlab_crop</span><span class="p">(</span><span class="n">ssim_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="SSIM_structure"><a class="viewcode-back" href="../../dippykit.metrics.html#dippykit.metrics.SSIM_structure">[docs]</a><span class="k">def</span> <span class="nf">SSIM_structure</span><span class="p">(</span>
        <span class="n">im_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">im_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">K1</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">K2</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
        <span class="n">use_gaussian_window</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_range</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">auto_downsample</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_sample_covariance</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">like_matlab</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns the mean structure component of the SSIM index and structure</span>
<span class="sd">    component of the SSIM image for a comparison of two images</span>

<span class="sd">    Given two images, this function will return the mean structure component</span>
<span class="sd">    of the SSIM index and structure component of the full SSIM image.</span>

<span class="sd">    This function is heavily based on `skimage.measure.compare_ssim`_,</span>
<span class="sd">    so more detailed documentation may be found there.</span>

<span class="sd">    :type im_1: ``numpy.ndarray``</span>
<span class="sd">    :param im_1: The first image in the comparison</span>
<span class="sd">    :type im_2: ``numpy.ndarray``</span>
<span class="sd">    :param im_2: The second image in the comparison</span>
<span class="sd">    :type K1: ``float``</span>
<span class="sd">    :param K1: (default=0.01) The K1 parameter used in the SSIM calculation</span>
<span class="sd">    :type K2: ``float``</span>
<span class="sd">    :param K2: (default=0.03) The K2 parameter used in the SSIM calculation</span>
<span class="sd">    :type use_gaussian_window: ``bool``</span>
<span class="sd">    :param use_gaussian_window: (default=False) If set to True,</span>
<span class="sd">        this function will use a gaussian window for the SSIM calculation</span>
<span class="sd">    :type window_size: ``int``</span>
<span class="sd">    :param window_size: (Optional) The size of the window to be used in the</span>
<span class="sd">        SSIM calculation. If **use_gaussian_window** is set to True,</span>
<span class="sd">        then this argument is ignored.</span>
<span class="sd">    :type data_range: ``float``</span>
<span class="sd">    :param data_range: (Optional) The range of values that the image can span.</span>
<span class="sd">        If this parameter is not set, then the range will be determined</span>
<span class="sd">        from the minimum and maximum values of the images. For uint8</span>
<span class="sd">        images, this value should be 255.</span>
<span class="sd">    :type sigma: ``float``</span>
<span class="sd">    :param sigma: (Optional) If **use_gaussian_window** is set to True,</span>
<span class="sd">        this parameter determines the sigma used for the gaussian window.</span>
<span class="sd">    :type auto_downsample: ``bool``</span>
<span class="sd">    :param auto_downsample: (default=True) If set to True, this function will</span>
<span class="sd">        automatically downsample the inputs. The downsampling consists of</span>
<span class="sd">        finding the smallest of the images&#39; first two dimensions (number of</span>
<span class="sd">        rows and number of columns), dividing this value by 256, rounding</span>
<span class="sd">        the output, and setting this final value as the scaling factor (sf). A</span>
<span class="sd">        square (sf x sf) lowpass averaging filter is then applied to both</span>
<span class="sd">        images with mode &#39;same&#39;. Finally, the two images are downsampled by</span>
<span class="sd">        sf in each dimension.</span>
<span class="sd">    :type use_sample_covariance: ``bool``</span>
<span class="sd">    :param use_sample_covariance: (default=False) If set to True,</span>
<span class="sd">        this function will use sample covariances in its calculations.</span>
<span class="sd">        Otherwise, covariances of 1 will be used.</span>
<span class="sd">    :type like_matlab: ``bool``</span>
<span class="sd">    :param like_matlab: If set to True, this function will act like the</span>
<span class="sd">        Matlab function ssim_index. This is merely a specific configuration</span>
<span class="sd">        of the above parameters.</span>
<span class="sd">    :param kwargs: For a full list of keyword arguments, see</span>
<span class="sd">        `skimage.measure.compare_ssim`_.</span>
<span class="sd">    :rtype: ``(float, numpy.ndarray)``</span>
<span class="sd">    :return: A tuple of two elements. The first element is the mean SSIM</span>
<span class="sd">        index. The second element is the full SSIM image.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        `skimage.measure.compare_ssim`_</span>
<span class="sd">            Documentation of the compare_ssim function from Scikit Image</span>
<span class="sd">        `SSIM Wikipedia Page`_</span>
<span class="sd">            Wikipedia page describing the formulae for SSIM calculations</span>

<span class="sd">    .. _skimage.measure.compare_ssim: http://scikit-image.org/docs/dev/api/</span>
<span class="sd">        skimage.measure.html#skimage.measure.compare_ssim</span>

<span class="sd">    .. _SSIM Wikipedia Page: https://en.wikipedia.org/wiki/</span>
<span class="sd">        Structural_similarity#Formula_components</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_SSIM_preprocess</span><span class="p">(</span><span class="n">im_1</span><span class="o">=</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="o">=</span><span class="n">im_2</span><span class="p">,</span> <span class="n">K1</span><span class="o">=</span><span class="n">K1</span><span class="p">,</span>
            <span class="n">K2</span><span class="o">=</span><span class="n">K2</span><span class="p">,</span> <span class="n">use_gaussian_window</span><span class="o">=</span><span class="n">use_gaussian_window</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data_range</span><span class="o">=</span><span class="n">data_range</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">auto_downsample</span><span class="o">=</span><span class="n">auto_downsample</span><span class="p">,</span>
            <span class="n">use_sample_covariance</span><span class="o">=</span><span class="n">use_sample_covariance</span><span class="p">,</span>
            <span class="n">like_matlab</span><span class="o">=</span><span class="n">like_matlab</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">callback_func</span><span class="p">(</span><span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uxx</span><span class="p">,</span> <span class="n">uyy</span><span class="p">,</span> <span class="n">uxy</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vxy</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">vxy</span> <span class="o">+</span> <span class="p">(</span><span class="n">C2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(((</span><span class="n">vx</span> <span class="o">*</span> <span class="n">vy</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">C2</span> <span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">like_matlab</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compare_ssim_with_callback</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span>
                <span class="n">callback_func</span><span class="o">=</span><span class="n">callback_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mssim</span><span class="p">,</span> <span class="n">ssim_map</span> <span class="o">=</span> <span class="n">_compare_ssim_with_callback</span><span class="p">(</span><span class="n">im_1</span><span class="p">,</span> <span class="n">im_2</span><span class="p">,</span>
                <span class="n">callback_func</span><span class="o">=</span><span class="n">callback_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mssim</span><span class="p">,</span> <span class="n">_SSIM_like_matlab_crop</span><span class="p">(</span><span class="n">ssim_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Brighton Ancelin.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>