

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dippykit.coding &mdash; dippykit  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="dippykit  documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> dippykit
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.html">dippykit package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.adjustments.html">dippykit.adjustments module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.coding.html">dippykit.coding module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.image_io.html">dippykit.image_io module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.metrics.html">dippykit.metrics module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.sampling.html">dippykit.sampling module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.transforms.html">dippykit.transforms module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.utilities.html">dippykit.utilities module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.visualization.html">dippykit.visualization module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dippykit.windows.html">dippykit.windows module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dippykit</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>dippykit.coding</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for dippykit.coding</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module of various image coding functions</span>

<span class="sd">This module contains an assortment of functions that encode or decode images</span>
<span class="sd">in popular or useful manners.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># This library was developed for the Georgia Tech graduate course ECE 6258:</span>
<span class="c1"># Digital Image Processing with Professor Ghassan AlRegib.</span>
<span class="c1"># For comments and feedback, please email dippykit[at]gmail.com</span>

<span class="c1"># Functional imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="k">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span><span class="p">,</span> <span class="n">heapify</span>

<span class="c1"># General imports</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Brighton Ancelin, Motaz Alfarraj, Ghassan AlRegib&#39;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;JPEG_Q_table_luminance&#39;</span><span class="p">,</span> <span class="s1">&#39;huffman_encode&#39;</span><span class="p">,</span> <span class="s1">&#39;huffman_decode&#39;</span><span class="p">,</span>
           <span class="s1">&#39;huffman_dict&#39;</span><span class="p">,</span> <span class="s1">&#39;huffman_tree&#39;</span><span class="p">]</span>


<span class="sd">&quot;&quot;&quot;The quantization table used by JPEG for encoding luminance values&quot;&quot;&quot;</span>
<span class="n">JPEG_Q_table_luminance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span> <span class="mi">16</span><span class="p">,</span>  <span class="mi">11</span><span class="p">,</span>  <span class="mi">10</span><span class="p">,</span>  <span class="mi">16</span><span class="p">,</span>  <span class="mi">24</span><span class="p">,</span>  <span class="mi">40</span><span class="p">,</span>  <span class="mi">51</span><span class="p">,</span>  <span class="mi">61</span><span class="p">],</span>
    <span class="p">[</span> <span class="mi">12</span><span class="p">,</span>  <span class="mi">12</span><span class="p">,</span>  <span class="mi">14</span><span class="p">,</span>  <span class="mi">19</span><span class="p">,</span>  <span class="mi">26</span><span class="p">,</span>  <span class="mi">58</span><span class="p">,</span>  <span class="mi">60</span><span class="p">,</span>  <span class="mi">55</span><span class="p">],</span>
    <span class="p">[</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">13</span><span class="p">,</span>  <span class="mi">16</span><span class="p">,</span>  <span class="mi">24</span><span class="p">,</span>  <span class="mi">40</span><span class="p">,</span>  <span class="mi">57</span><span class="p">,</span>  <span class="mi">69</span><span class="p">,</span>  <span class="mi">56</span><span class="p">],</span>
    <span class="p">[</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">17</span><span class="p">,</span>  <span class="mi">22</span><span class="p">,</span>  <span class="mi">29</span><span class="p">,</span>  <span class="mi">51</span><span class="p">,</span>  <span class="mi">87</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span>  <span class="mi">62</span><span class="p">],</span>
    <span class="p">[</span> <span class="mi">18</span><span class="p">,</span>  <span class="mi">22</span><span class="p">,</span>  <span class="mi">37</span><span class="p">,</span>  <span class="mi">56</span><span class="p">,</span>  <span class="mi">68</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span>  <span class="mi">77</span><span class="p">],</span>
    <span class="p">[</span> <span class="mi">24</span><span class="p">,</span>  <span class="mi">35</span><span class="p">,</span>  <span class="mi">55</span><span class="p">,</span>  <span class="mi">64</span><span class="p">,</span>  <span class="mi">81</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">113</span><span class="p">,</span>  <span class="mi">92</span><span class="p">],</span>
    <span class="p">[</span> <span class="mi">49</span><span class="p">,</span>  <span class="mi">64</span><span class="p">,</span>  <span class="mi">78</span><span class="p">,</span>  <span class="mi">87</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">101</span><span class="p">],</span>
    <span class="p">[</span> <span class="mi">72</span><span class="p">,</span>  <span class="mi">92</span><span class="p">,</span>  <span class="mi">95</span><span class="p">,</span>  <span class="mi">98</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span>  <span class="mi">99</span><span class="p">],</span>
<span class="p">])</span>


<div class="viewcode-block" id="huffman_encode"><a class="viewcode-back" href="../../dippykit.coding.html#dippykit.coding.huffman_encode">[docs]</a><span class="k">def</span> <span class="nf">huffman_encode</span><span class="p">(</span>
        <span class="n">im_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">symbol_code_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Encodes an integer vector using huffman encoding</span>
<span class="sd">    </span>
<span class="sd">    Given a vector (one-dimensional ndarray) with either signed or unsigned </span>
<span class="sd">    integer dtype, this function huffman encodes it. The process for this is </span>
<span class="sd">    the following:</span>
<span class="sd">    </span>
<span class="sd">    #. If no symbol-code dictionary is provided, create one. The symbol </span>
<span class="sd">       code dictionary (symbol_code_dict) correlates the values in the input </span>
<span class="sd">       vector to the variable-bit-length values in the output vector. In the </span>
<span class="sd">       case that no symbol-code dictionary was provided, a symbol-probability </span>
<span class="sd">       dictionary (symbol_probability_dict) is generated. This symbol </span>
<span class="sd">       probability dictionary has a key set of all unique symbols in im_vec </span>
<span class="sd">       and a value set containing each unique symbol&#39;s frequency in im_vec. </span>
<span class="sd">       The symbol-code dictionary is then generated using </span>
<span class="sd">       :func:`huffman_dict` with the symbol-probability dictionary as its </span>
<span class="sd">       argument. This symbol-code dictionary now contains the statistically </span>
<span class="sd">       optimal compressive encoding scheme.</span>
<span class="sd">        </span>
<span class="sd">    #. Translate the im_vec vector into its huffman encoded version by </span>
<span class="sd">       replacing each integer value with its appropriate bit sequence in the </span>
<span class="sd">       the symbol-code dictionary. </span>
<span class="sd">    </span>
<span class="sd">    #. Pack the bit sequence into a byte sequence (represented as a </span>
<span class="sd">       one-dimensional ndarray of dtype ``uint8``). The last byte is </span>
<span class="sd">       right-padded with 0s if the number of bits in the bit sequence was not </span>
<span class="sd">       a perfect multiple of 8. </span>
<span class="sd">    </span>
<span class="sd">    #. Return the following data (in order) as a tuple:</span>
<span class="sd">    </span>
<span class="sd">        * byte sequence</span>
<span class="sd">        * the number of bits in the previous step&#39;s bit stream</span>
<span class="sd">        * the symbol-code dictionary (symbol_code_dict)</span>
<span class="sd">        * the symbol-probability dictionary (symbol_probability_dict)</span>
<span class="sd">        </span>
<span class="sd">    To reverse the huffman encoding, you can pass the first, third, </span>
<span class="sd">    and second returned values to the :func:`huffman_decode` function in </span>
<span class="sd">    that order. Optionally, (for optimal speed) pass the length of the </span>
<span class="sd">    original image vector (im_vec) to :func:`huffman_decode` as the </span>
<span class="sd">    init_arr_size keyword argument.</span>
<span class="sd">    </span>
<span class="sd">    :type im_vec: ``numpy.ndarray``</span>
<span class="sd">    :param im_vec: A vector with either signed integer or unsigned integer </span>
<span class="sd">        dtype to be huffman encoded. With images, one can trivially make them </span>
<span class="sd">        vectors by using the numpy method **im.reshape(-1)**.</span>
<span class="sd">    :type symbol_code_dict: ``Dict[int, numpy.ndarray]``</span>
<span class="sd">    :param symbol_code_dict: (Optional) A dictionary with either a signed </span>
<span class="sd">        integer or unsigned integer key set and a value set of unique bit </span>
<span class="sd">        sequences (represented as one-dimensional ndarrays with boolean dtype).</span>
<span class="sd">    :rtype: (``numpy.ndarray``, ``int``, ``Dict[int, np.ndarray]``,</span>
<span class="sd">        ``Dict[int, float]``)</span>
<span class="sd">    :return: A tuple containing the following, in order:</span>
<span class="sd">    </span>
<span class="sd">        * The huffman encoded byte sequence of the input im_vec</span>
<span class="sd">        * The number of bits needed to represent the encoded im_vec</span>
<span class="sd">        * The symbol-code dictionary which translates integer symbols to </span>
<span class="sd">          binary codes</span>
<span class="sd">        * The symbol-probability dictionary which translates integer symbols to</span>
<span class="sd">          probability weights</span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im = np.array([[  0, 255, 255,   0],</span>
<span class="sd">    ...                [255,   0,  64, 128]])</span>
<span class="sd">    &gt;&gt;&gt; im_vec = im.reshape(-1)</span>
<span class="sd">    &gt;&gt;&gt; im_vec</span>
<span class="sd">    array([  0, 255, 255,   0, 255,   0,  64, 128])</span>
<span class="sd">    &gt;&gt;&gt; im_encoded, stream_length, symbol_code_dict, symbol_prob_dict = </span>
<span class="sd">    ...         huffman_encode(im_vec)</span>
<span class="sd">    &gt;&gt;&gt; im_encoded</span>
<span class="sd">    array([205, 202], dtype=uint8)</span>
<span class="sd">    &gt;&gt;&gt; np.unpackbits(im_encoded)</span>
<span class="sd">    array([1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0], dtype=uint8)</span>
<span class="sd">    &gt;&gt;&gt; stream_length</span>
<span class="sd">    15</span>
<span class="sd">    &gt;&gt;&gt; symbol_code_dict</span>
<span class="sd">    {255: array([False]), </span>
<span class="sd">     0: array([ True,  True]), </span>
<span class="sd">     64: array([ True, False, False]), </span>
<span class="sd">     128: array([ True, False,  True])}</span>
<span class="sd">    &gt;&gt;&gt; symbol_prob_dict</span>
<span class="sd">    {0: 3, </span>
<span class="sd">     64: 1, </span>
<span class="sd">     128: 1, </span>
<span class="sd">     255: 3}</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="s1">&#39;i&#39;</span> <span class="o">==</span> <span class="n">im_vec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">or</span> <span class="s1">&#39;u&#39;</span> <span class="o">==</span> <span class="n">im_vec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> \
            <span class="s2">&quot;Image vector must be an integer dtype for huffman encoding.&quot;</span>
    <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_vec</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> \
            <span class="s2">&quot;Image vector must be a 1-dimensional ndarray.&quot;</span>
    <span class="k">if</span> <span class="n">symbol_code_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">symbols</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">im_vec</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">symbol_probability_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
        <span class="n">symbol_code_dict</span> <span class="o">=</span> <span class="n">huffman_dict</span><span class="p">(</span><span class="n">symbol_probability_dict</span><span class="p">)</span>
    <span class="n">im_enco</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol_code_dict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">im_vec</span><span class="p">]</span>
    <span class="n">im_enco</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">im_enco</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">(</span><span class="n">im_enco</span><span class="p">),</span> <span class="n">im_enco</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">symbol_code_dict</span><span class="p">,</span> \
           <span class="n">symbol_probability_dict</span></div>


<div class="viewcode-block" id="huffman_decode"><a class="viewcode-back" href="../../dippykit.coding.html#dippykit.coding.huffman_decode">[docs]</a><span class="k">def</span> <span class="nf">huffman_decode</span><span class="p">(</span>
        <span class="n">im_encoded</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">symbol_code_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">stream_length</span><span class="p">:</span> <span class="nb">int</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">init_arr_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Decodes a huffman encoded byte stream</span>
<span class="sd">    </span>
<span class="sd">    Given a huffman encoded byte stream and a symbol-code dictionary, </span>
<span class="sd">    this function will decode the byte stream into its original form.</span>
<span class="sd">    </span>
<span class="sd">    The huffman encoded byte stream (im_encoded) must be represented as a </span>
<span class="sd">    one-dimensional ndarray with dtype ``uint8``. The symbol-code dictionary </span>
<span class="sd">    must be represented as a dictionary that maps either signed integer or </span>
<span class="sd">    unsigned integer symbols to ndarrays with boolean dtype (these ndarrays </span>
<span class="sd">    are the binary huffman codes that compose im_encoded). </span>
<span class="sd">    </span>
<span class="sd">    The stream_length argument (optional) is an integer that represents the </span>
<span class="sd">    number of bits in im_encoded that actually represent the image vector. </span>
<span class="sd">    Often times, huffman encoding a vector yields a bit stream whose length </span>
<span class="sd">    is not a perfect multiple of 8, therefore the byte stream will be padded </span>
<span class="sd">    at the end with 0s. Specifying stream_length prevents against extra </span>
<span class="sd">    additional values that may arise from these padded 0s.</span>
<span class="sd">    </span>
<span class="sd">    The init_arr_size argument (optional) is an integer that represents the </span>
<span class="sd">    number of elements that the user anticipates the decoded image vector to </span>
<span class="sd">    have. **This value has no effect on the output of the function, its only </span>
<span class="sd">    purpose is to speed up computation. This value can be a rough estimate.** </span>
<span class="sd">    </span>
<span class="sd">    To huffman encode an image vector, see :func:`huffman_encode`.</span>
<span class="sd">    </span>
<span class="sd">    :type im_encoded: ``numpy.ndarray``</span>
<span class="sd">    :param im_encoded: A one-dimensional ndarray of dtype ``uint8`` composed </span>
<span class="sd">        of huffman encoded values.</span>
<span class="sd">    :type symbol_code_dict: ``Dict[int, np.ndarray]``</span>
<span class="sd">    :param symbol_code_dict: A dictionary that maps either signed integer or </span>
<span class="sd">        unsigned integer symbols for the decoded image to binary huffman </span>
<span class="sd">        codes present in the im_encoded vector.</span>
<span class="sd">    :type stream_length: ``int``</span>
<span class="sd">    :param stream_length: (Optional) The number of bits from the im_encoded </span>
<span class="sd">        vector to decode.</span>
<span class="sd">    :type init_arr_size: ``int``</span>
<span class="sd">    :param init_arr_size: (Optional) The anticipated number of elements in </span>
<span class="sd">        the decoded image. **This parameter has no effect on the return value </span>
<span class="sd">        of this function. It only reduces the computation time when it is </span>
<span class="sd">        close to the actual number of elements in the decoded image.**</span>
<span class="sd">    :rtype: ``numpy.ndarray``</span>
<span class="sd">    :return: The decoded image vector, represented as a one-dimensional </span>
<span class="sd">        ndarray with dtype ``int64``.</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; im = np.array([[  0, 255, 255,   0],</span>
<span class="sd">    ...                [255,   0,  64, 128]])</span>
<span class="sd">    &gt;&gt;&gt; im_vec = im.reshape(-1)</span>
<span class="sd">    &gt;&gt;&gt; im_vec</span>
<span class="sd">    array([  0, 255, 255,   0, 255,   0,  64, 128])</span>
<span class="sd">    &gt;&gt;&gt; im_encoded, stream_length, symbol_code_dict, symbol_prob_dict = </span>
<span class="sd">    ...         huffman_encode(im_vec)</span>
<span class="sd">    &gt;&gt;&gt; huffman_decode(im_encoded, symbol_code_dict)</span>
<span class="sd">    array([  0, 255, 255,   0, 255,   0,  64, 128, 255], dtype=int64)</span>
<span class="sd">    &gt;&gt;&gt; huffman_decode(im_encoded, symbol_code_dict, stream_length)</span>
<span class="sd">    array([  0, 255, 255,   0, 255,   0,  64, 128], dtype=int64)</span>
<span class="sd">    &gt;&gt;&gt; huffman_decode(im_encoded, symbol_code_dict, stream_length, </span>
<span class="sd">    ...         im_vec.size)</span>
<span class="sd">    array([  0, 255, 255,   0, 255,   0,  64, 128], dtype=int64)</span>
<span class="sd">    &gt;&gt;&gt; huffman_decode(im_encoded, symbol_code_dict, stream_length, 1)</span>
<span class="sd">    array([  0, 255, 255,   0, 255,   0,  64, 128], dtype=int64)</span>
<span class="sd">    &gt;&gt;&gt; huffman_decode(im_encoded, symbol_code_dict, stream_length, 10000)</span>
<span class="sd">    array([  0, 255, 255,   0, 255,   0,  64, 128], dtype=int64)</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="s1">&#39;uint8&#39;</span> <span class="o">==</span> <span class="n">im_encoded</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_encoded</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> \
            <span class="s2">&quot;Encoded image must be a 1-dimensional ndarray of dtype uint8.&quot;</span>
    <span class="n">huff_root</span> <span class="o">=</span> <span class="n">huffman_tree</span><span class="p">(</span><span class="n">symbol_code_dict</span><span class="p">)</span>
    <span class="n">bit_stream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">im_encoded</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">stream_length</span><span class="p">:</span>
        <span class="n">bit_stream</span> <span class="o">=</span> <span class="n">bit_stream</span><span class="p">[:</span><span class="n">stream_length</span><span class="p">]</span>
    <span class="n">ret_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
    <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">init_arr_size</span><span class="p">:</span>
        <span class="c1"># Arbitrarily chosen size</span>
        <span class="n">im_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bit_stream</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ret_dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">im_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">init_arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ret_dtype</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cur_huff_node</span> <span class="o">=</span> <span class="n">huff_root</span>
    <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bit_stream</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bit</span><span class="p">:</span>
            <span class="n">cur_huff_node</span> <span class="o">=</span> <span class="n">cur_huff_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_huff_node</span> <span class="o">=</span> <span class="n">cur_huff_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cur_huff_node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">im_vec</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="c1"># Arbitrarily chosen size increase</span>
                <span class="n">im_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im_vec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">1.05</span><span class="o">*</span><span class="n">im_vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                                                    <span class="n">dtype</span><span class="o">=</span><span class="n">ret_dtype</span><span class="p">))</span>
            <span class="n">im_vec</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_huff_node</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cur_huff_node</span> <span class="o">=</span> <span class="n">huff_root</span>
    <span class="n">im_vec</span> <span class="o">=</span> <span class="n">im_vec</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">im_vec</span></div>


<div class="viewcode-block" id="huffman_dict"><a class="viewcode-back" href="../../dippykit.coding.html#dippykit.coding.huffman_dict">[docs]</a><span class="k">def</span> <span class="nf">huffman_dict</span><span class="p">(</span>
        <span class="n">symbol_probability_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Generates a symbol-code dictionary using huffman encoding</span>

<span class="sd">    Given a dictionary where each key is a symbol in some integer vector and</span>
<span class="sd">    the corresponding values are floating point weights of the frequency of</span>
<span class="sd">    occurrence of said symbol, this function returns a dictionary with an</span>
<span class="sd">    identical key set as the input but with corresponding values</span>
<span class="sd">    representing the huffman codes of each symbol. These huffman codes are</span>
<span class="sd">    represented as vectors (one-dimensional ndarray) with boolean dtype.</span>

<span class="sd">    The algorithm used in this implementation of huffman dictionary</span>
<span class="sd">    generation is based on that of `RosettaCode</span>
<span class="sd">    &lt;https://rosettacode.org/wiki/Huffman_coding#Python&gt;`_ .</span>

<span class="sd">    :type symbol_probability_dict: ``Dict[int, float]``</span>
<span class="sd">    :param symbol_probability_dict: A dictionary with integer symbol keys</span>
<span class="sd">        and frequency weighting values</span>
<span class="sd">    :rtype: ``Dict[int, numpy.ndarray]``</span>
<span class="sd">    :return: A dictionary with the same integer symbol keys as the</span>
<span class="sd">        symbol_probability_dict argument but with huffman code values.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; rand_vec = np.array([0, 0, 1, 2, 2, 2, 2, 3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; symbols, values = np.unique(rand_vec, return_counts=True)</span>
<span class="sd">    &gt;&gt;&gt; symbols</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; values</span>
<span class="sd">    array([2, 1, 4, 3], dtype=int64)</span>
<span class="sd">    &gt;&gt;&gt; symbol_probability_dict = dict(zip(symbols, values))</span>
<span class="sd">    &gt;&gt;&gt; symbol_probability_dict</span>
<span class="sd">    {0: 2,</span>
<span class="sd">     1: 1,</span>
<span class="sd">     2: 4,</span>
<span class="sd">     3: 3}</span>
<span class="sd">    &gt;&gt;&gt; huffman_dict(symbol_probability_dict)</span>
<span class="sd">    {2: array([False]),</span>
<span class="sd">     3: array([ True,  True]),</span>
<span class="sd">     0: array([ True, False,  True]),</span>
<span class="sd">     1: array([ True, False, False])}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[[</span><span class="n">prob</span><span class="p">,</span> <span class="p">[</span><span class="n">sym</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)]]</span> <span class="k">for</span> <span class="n">sym</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span>
            <span class="n">symbol_probability_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">heapify</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">lo</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">hi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">[</span><span class="n">lo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">hi</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">lo</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">hi</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span></div>


<div class="viewcode-block" id="huffman_tree"><a class="viewcode-back" href="../../dippykit.coding.html#dippykit.coding.huffman_tree">[docs]</a><span class="k">def</span> <span class="nf">huffman_tree</span><span class="p">(</span>
        <span class="n">symbol_code_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generates a huffman tree from a symbol-code dictionary</span>

<span class="sd">    Given a symbol-code dictionary, this function generates a corresponding</span>
<span class="sd">    huffman tree. This huffman tree is a binary tree, and is represented as a</span>
<span class="sd">    length 2 list of nested length 2 lists. The first element in these</span>
<span class="sd">    length 2 lists represents a 0 in the huffman code, and the second</span>
<span class="sd">    element represents a 1 in the huffman code.</span>

<span class="sd">    :type symbol_code_dict: ``Dict[int, numpy.ndarray]``</span>
<span class="sd">    :param symbol_code_dict: A symbol-code dictionary that maps either</span>
<span class="sd">        signed integer or unsigned integer symbols to binary huffman codes.</span>
<span class="sd">        These binary huffman codes are represented as ndarrays with boolean</span>
<span class="sd">        dtype.</span>
<span class="sd">    :rtype: ``List``</span>
<span class="sd">    :return: The huffman tree corresponding to the symbol-code dictionary,</span>
<span class="sd">        represented as a list of nested lists.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; symbol_code_dict = {0: np.array([ True,  True]),</span>
<span class="sd">    ...                     3: np.array([ True, False]),</span>
<span class="sd">    ...                     4: np.array([False, False]),</span>
<span class="sd">    ...                     1: np.array([False, True,  True]),</span>
<span class="sd">    ...                     2: np.array([False,  True, False])}</span>
<span class="sd">    &gt;&gt;&gt; huffman_tree(symbol_code_dict)</span>
<span class="sd">    [[4, [2, 1]], [3, 0]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">root</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">symbol_code_dict</span><span class="p">:</span>
        <span class="n">huff_code</span> <span class="o">=</span> <span class="n">symbol_code_dict</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">cur_node</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">huff_code</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_node</span><span class="p">):</span>
                <span class="n">cur_node</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
                <span class="n">cur_node</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bit</span><span class="p">:</span>
                <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_node</span><span class="p">):</span>
            <span class="n">cur_node</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">cur_node</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">huff_code</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">cur_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>
    <span class="k">return</span> <span class="n">root</span></div>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Brighton Ancelin, Motaz Alfarraj, Ghassan AlRegib.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>